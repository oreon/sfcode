«IMPORT org::openarchitectureware::meta::uml::classifier»
«EXTENSION java::NamingConventions»
«EXTENSION java::Associations»

«DEFINE ReferenceVariables FOR Class»
«FOREACH AssociationEnd.Opposite.select(ae|ae.isNavigable) AS ae»
private «ae.fqn()»  ;
«ENDFOREACH»
«ENDDEFINE»

«DEFINE AccessorMethods FOR Class»
«EXPAND ToOneAccessorMethods FOREACH
AssociationEnd.Opposite.select(ae|!ae.isMultiple && ae.isNavigable)»
«EXPAND ToManyAccessorMethods FOREACH
AssociationEnd.Opposite.select(ae|ae.isMultiple && ae.isNavigable)»
«ENDDEFINE»

«DEFINE ToOneAccessorMethods FOR AssociationEnd»

public void «asSetter()» («Class.fqn()» «asParameter()») {
this.«asInstanceVar()» = «asParameter()»;
}

«manyToOne()»
public «Class.fqn()» «asGetter()» () {
return this.«asInstanceVar()»;
}
«ENDDEFINE»

«DEFINE ToManyAccessorMethods FOR AssociationEnd»
public void add«NameS.toFirstUpper()» («Class.fqn()» «asParameter()») {
	«IF Opposite.isNavigable »
		«asParameter()».«Opposite.asSetter()»(this);
	«ENDIF»
	this.«asInstanceVar()».add(«asParameter()»);
}

public void remove«NameS.toFirstUpper()» («Class.fqn()»
«asParameter()») {
this.«asInstanceVar()».remove(«asParameter()»);
}

«IF Opposite.isNavigable »
@OneToMany(mappedBy="«Opposite.asParameter()»", fetch=FetchType.LAZY, cascade=CascadeType.ALL)
«ELSE»
@OneToMany«Opposite.isComposition?"(cascade=CascadeType.ALL)":""»
@JoinColumn(name="«Opposite.NameS»_ID", nullable=false)
«ENDIF»
public java.util.Set<«Class.fqn()»> «asGetter()» () {
return this.«asInstanceVar()»;
}

public void «asSetter()» (java.util.Set<«Class.fqn()»> «asParameter()») {
	this.«asInstanceVar()» = «asParameter()»;
}

@Transient
public «iterator()» «asGetter()»Iterator () {
return this.«asInstanceVar()».iterator();
}
«ENDDEFINE»